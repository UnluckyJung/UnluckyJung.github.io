---
title: 데이터베이스 트랜잭션과 고립화 레벨
date: 2020-11-20-17:00
categories:
- DB

tags:
- MYSQL
- DB

photos:
- /post_images/mysql.png

---

## 트랜잭션
> Transation 이란 무엇인가.

### 트랜잭션이 왜 필요한가
* 만약 두개의 테이블이 있다고 가정하자.
    * 주문번호, 날짜, 고객번호를 가진 `테이블 A`
    * 주문번호, 상품코드, 주문한 상품개수를 가진 `테이블 B`

* 주문이 발생했다고 생각하자.
    * 주문번호가 생성되고, 현재 시간과, 주문한 고객정보가 `테이블 A` 에 추가가 될것이다.
    * 이때 `테이블 B` 의 정보도 같이 추가되어야 한다.
    * 만약 고객이 여러종류, 여러개의 상품을 구매했다면 `테이블 B` 에는 여러 행이 추가 될것이다.

* 에러가 발생했다.
    * `테이블 B` 의 4번째 행을 추가할때 에러가 발생했다고 하자.
    * 그렇다면 1,2,3 번째의 행을 삭제해주어야 한다.
    * 이것을 일일히 다 삭제하고 하려면 굉장히 번거롭고 귀찮은 작업이다.

> 이런 작업들을 한번에 묶어서 처리할수 없을까??  

* **트랜잭션** 을 이용한다.

### 트랜잭션의 임시공간
* 트랜잭션은 여러개의 SQL 명령을 한개의 작업으로 묶을 수 있다.
* 이때 SQL 명령의 결과들은 임시공간에 저장되고 있고, `COMMIT`을 하게 되면 실제 테이블에 적용이 된다.
* `COMMIT` : 트랜잭션을 통해 변경된 사항을 적용하는 명령
* `ROLLBACK` : 변경된 사항을 적용하지 않고 종료하는 명령
    * 위의 예시의 경우, `ROLLBACK` 을 하면 깔끔하게 처리가 된다.


---

## 트랜잭션 고립화
> 트랜잭션 고립화가 왜필요할까.

* 데이터베이스는 무결성을 중요하는것이 무엇보다 중요하다.
* 트랜잭션은 여러개의 `SQL` 명령을 처리 하는데, 이때 중간에 다른 트랜잭션이나 SQL 명령으로 인해 데이터 베이스내 데이터에 영항을 준다면 일관성과 무결성이 무너질 수 있다.
* 이것을 방지하기 위해 한 트랜잭션이 처리중일때, 다른 트랜잭션은 DB에 접근하지 못하게 하는 `Locking` 이라는 방법을 쓴다.
    * 하지만 과도한 `Locking` 은 성능을 떨어뜨리게 된다.
* 이런 `Locking` 을 효율적으로 사용하는 방법을 정리한것이 `Iolation Level`이다.

---

## Isolation Level

### Read Uncommited
* 한 트랜잭션이 A를 B로 변경하고 있을때
    * 다른 트랜잭션이 A의 위치를 읽게 되면
    * A가 아닌 B라는 결과를 얻을 수 있다.
    * 이때 `Uncommited` 라는 단어처럼 아직 완료되지 않은 작업에 대한 접근이 가능해지는것이다.
* **이런 고립화 레벨에서는 일관성이 유지되지 않는다.**

### Read Commited
* 한 트랜잭션이 A를 B로 변경하고 있을때
    * 다른 트랙잭션은 **A의 위치를 읽을 수 없다**
    * 이 트랜잭션은 A라는 데이터의 변경이 모두 이루어졌을때 접근이 가능하다.
    * 그 전까지는 **대기** 하게 된다.

### Repeatable Read
* 트랜잭션이 완료될때까지 해당 데이터에는 `Locking`이 걸리게 된다.
    * 이때 트랜잭션이 직접적으로 변경하거나 접근하고 있는 데이터를 제외하고는 다른 데이터가 접근이 가능하다.
* `col`라는 열의 데이터에는 `{A B C D}` 가 있고
    * 트랜잭션1이 `col`의 데이터중 `A` 와 `C`에 접근하고 있다면
    * 트랜잭션2는 나머지인 `B`와 `D`에 접근할 수 있다.

### Serializable
* `Repeatable Read` 에서의 부분 접근조차 막아버린다.

---

## Reference
* [SQL 첫걸음](http://www.yes24.com/Product/Goods/22744867)
* https://goodgid.github.io/Transaction-Isolation-Level/
