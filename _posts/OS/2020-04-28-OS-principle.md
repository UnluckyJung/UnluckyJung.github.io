---
title: 컴퓨터 시스템의 동작원리
date: 2020-04-28-16:30
categories:
- OS

tags:
- OS
- 운영체제

# photos: 
# - 주소

---

## 컴퓨터 시스템의 동작원리를 간략하게 알아봅니다.
> 구조, 인터럽트, 동기, 비동기, DMA 캐싱 등등을 알아봅니다.

---

## 컴퓨터 시스템의 구조.
> 데이터가 들어오고 (input) / 나가는것 (output) 으로 진행

* 운영체제는 여러프로그램이 동시에 수행되는 시스템을 위한것
    * 항상 메모리에 올라가있는 일부분이 있어야한다.
    * 그것이 `kernel`

---

## CPU와 I/O 연산
> 컴퓨터에서 연산을 한다는것은 무언가 일을 하고 있다는 것

* I/O 장치는 `controller`와 `local buffer`가 있다
    * `controller` : CPU와 I/O 장치 사이에서 데이터를 가져오거나 보내는 명령을 수행하는 작은 **cpu**
    * `local buffer` : 데이터를 임시로 저장하는 작은 **메모리**
* 데이터를 다 가져왔는지 CPU가 일일히 확인 `polling` (자원 낭비)
* 작업을 마친뒤 **신호**를 통해 CPU에게 보고하는 방식 `interrupt`
    * `controller`가 발생시킨다.

---

## 인터럽트의 일반적 기능
> 인터럽트 관련 업무를 CPU가 수행하도록 만듬.

* `인터럽트 벡터` : 인터럽트로 인해 수행해야되는 할일을 가르키고 있는 **포인터** 자료구조
* `인터럽트 처리루틴` : 인터럽트로 인해 실제로 수행해야 되는 할일을 프로그래밍 해둔것.
* 인터럽트로 인해 발생한 일을 마친뒤, 돌아갈 장소를 저장해야함 `PCB`

* 하드웨어 인터럽트 : 컨트롤러 등 **하드웨어 장치**가 발생시킴.
* 소프트웨어 인터럽트 : **소프트웨어**가 발생시킴.

### 프로세스의 주소 공간
> 프로그램이 실행되면 프로세스가 생성되고 메모리에 주소공간이 할당됨.

* `Stack`
    * 다른 함수를 실행시켰을때, 돌아갈곳 위치 저장.
    * 함수, 지역변수, 매개변수 저장.
* `Data`
    * `전역(global)변수`, `정적(static)변수`등 각종 데이터가 저장되는 공간
    * 모든 함수들이 공유해서 사용할 수 있음.
* `Code`
    * 프로그래머가 작성한 코드가 기계어 형태로 저장된것.
* `Heap`
    * 동적할당으로 생성된 동적변수를 관리하기 위한 공간
    * 관리가 가능한 데이터 외 다른 형태의 데이터를 관리하기 위한 공간
    * 런타임에 결정된다.


#### 왜 이렇게 분할 했을까?
> 메모리 사용량의 최적화

* 데이터를 공유하여 메모리 사용량을 줄인다.
    * `Data`의 경우 모든 함수들이 **공유** 한다.
    * `Code`의 경우 프로그램내 같은 내용이므로 **공유** 한다

---

## 인터럽트 핸들링
> 인터럽트가 발생한 경우 처리해야 할 일의 절차들

* 인터럽트가 발생하면, 작업중이것을 `PCB`에 저장시키고, 인터럽트를 처리하러감.
    * `PCB` : 현재 수행중이던 메모리주소, 레지스터값, 하드웨어 상태등을 저장하는 자료구조.
* 인터럽트 처리 코드는 **커널** 의 코드를 수행하는것
    * 커널의 스택영역을 이용함.
    * 현재 수행중인 프로그램 개수만큼 독립적인 공간을 보유함
        * **WHY** : **커널**은 공유 코드와 같기 때문에
        * 인터럽트 수행도중 다른 인터럽트가 발생하면, 스택을 통해 작업을 관리함.

### 소프트웨어 인터럽트
> `Trap` 이라고도 불림

* `예외(exception)`
    * 0으로 나누기, 메모리 침범 등등 불가능한 작업을 시도
    * 종료시켜버림
* `System call`
    * 자신이 작성하지 않은 코드를 운영체제로부터 서비스 받기 위해 요청.
    * 운영체제에 정의된 함수를 호출하는 것

### 운영체제는 인터럽트 발생시에만 CPU를 얻는다.

---

## 입출력 구조
> 컴퓨터 시스템이 외부의 주변 장치들과 데이터를 주고 받는것

* `동기화` : 맞추어 진행하다.
    * 동일한것들 가지는것
    * 동일하게 하는것.

### 동기식 입출력
> 프로그램이 입출력 업무 수행을 마친 뒤에서야 그 프로그램이 다시 CPU를 얻을 수 있는것.

* I/O 장치는 CPU보다 몹시 느리다
* 입출력 업무를 하는동안 CPU를 잡고 있으면 자원의 낭비가 크다
* 작업중인 프로그램은 `blocked state`로 전환시킨다. CPU를 뺏어가 다른 프로그램을 수행한다.
    * `blocked state` : CPU를 할당받을 수 없는 상태
    * 업무가 마치면 인터럽트를 통해 해제시킴
* 만약 다른 프로그램이, 사용중인 같은 자원에 접근한다면?
    * `queue`에 줄세워서 순차적으로 진행시킨다
* 데이터를 주고 받는 **순서가 중요**할때 사용되어짐.

### 비동기식 입출력
> 프로그램이 바로 CPU를 다시 획득하는것

* 프로그램이 작업을 수행중이지만, CPU를 계속 잡고 있는것.
* **동기식이 아니다.** 바로 다른 작업을 수행하는것.
* 동기식과 마찬가지로, 업무가 끝나면 인터럽트를 발생시켜 업무가 끝났음을 보고함.
* **다수의 작업처리**에 유용하다.

---

## DMA (Direct Memory Access)
> 로컬버퍼와 메모리사이의 데이터를 옮겨주는 일을 수행

* 메모리 접근 연산이 CPU로만 이루어지면 매번 CPU에게 요청해야함. **비효율적**
* CPU가 자주 인터럽트 요청을 받는것을 방지
* CPU의 작업을 대행함.
    * `block`이라는 큰 단위로 메모리에 가져옴.
    * 작업을 마친뒤에 CPU 에게 인터럽트 발생.

---

## 저장 장치의 계층구조
> 용량이 작을수록 비싸고 성능이 좋다.

* 휘발성
    * 성능순 : `register` > `cache memory` > `memory`
* 비휘발성 
    * 성능순 : `magnetic disk` > `opical disk` > `magnetic tape`

### 캐슁 기법
> 상대적으로 용량이 적은 빠른 저장 장치의 성능향상을 위한 총체적 기법

* 필요한 정보만을 선별적으로 저장하면 성능에 유리해짐
* 당장 사용되거나, 빈번하게 사용될 정보를 **빠른 저장장치에 선별하여 저장**
* 프로그램은 모든부분이 균등하게 참조되는것이 아니라, 일부분이 집중적으로 참조 되어짐.

#### 지역성(Locality)
> `적중률 (Hit rate)` 를 위해 이용하는것

* 시간 지역성 : 최근에 참조된것이 또 참조될 가능성이 높다.
* 공간 지역성 : 실제 참조된것과 인접한 내용이 다시 참조될 가능성이 높다.

#### 캐싱 라인
> 캐시에 데이터를 묶어서 저장하는 자료구조

* 내가 원하는 데이터를 캐시에서 찾는것 역시 시간 낭비
* 캐시에 목적 데이터가 있을때 바로 접근할 수 있도록해줌.
    * 데이터의 메모리 주소도 같이 저장.

---

## 하드웨어의 보안
> 다중 프로그래밍 환경에서의 보안

* 프로그램간의 충돌을 방지 해아함.
* 디스크에 자유롭게 접근이 가능하다면, 다른 사람의 정보에 접근 가능해짐 **제한**이 필요함.

* `mod bit`를 이용하여 `커널모드`, `사용자모드` 두가지로 나눔
    * `mod bit`는 **하드웨어**적인 지원이 필요함. **0**인 경우 `커널모드`


### 커널모드
> 운영체제가 CPU의 제어권을 지님

* 모든 종료의 명령을 다 시행할 수 있음.

### 사용자모드
> 제한적인 명령만 수행할 수 있음.

* 시스템에 중요한 작업은 커널모드에서만 수행 할 수 있게 제한을 둠.
* 권한밖의 작업은 `System call`을 이용해 **대행**을 요청함.

---

## 메모리 보안
> 다른 프로그램의 메모리 영역을 침범하지 않게 해야함

* 프로그램들은 메모리에 동시에 올라가서 실행되어짐
* 제한을 두지 않는다면, 다른 메모리 영역을 침범하여 데이터를 조작 할 수 있게됨
* 만약 운영체제의 커널 부분을 침범한다면? **심각한 오류**

### 기준, 한계 레지스터 (하드웨어적인 지원)
> 프로그램별로 접근이 가능한 범위를 제한함.

**프로그램이 메모리에 연속적으로 위치할때의 경우**  

* `base` : 프로그램이 접근할 수 있는 **가장 작은 메모리 주소**
* `limit` : 접근 할 수 있는 **메모리의 범위**를 표시하고 있음.

### 입출력과, 메모리의 차이
* 입출력 명령은 **커널 모드** 에서만 가능
* 메모리 접근은 **사용자 모드** 에서도 가능
* 하지만, 기준 한계 레지스터의 값을 세팅하는 것은 **특권 명령**으로 설정해야함.

---

## CPU 보호
> CPU의 독점을 방지함

* `Timer` 하드웨어를 이용하여 일정시간이 지나면 `interrupt`을 발생시킴
* 한 프로그램이 CPU를 독점하지 못하게 **뺏어옴.**
* `시분할 시스템`에서 사용하는 방식.
    * `시분할 시스템` : 여러 프로그램이 CPU를 조금씩 나누어 사용하는 방법.

---

### 시스템 콜을 이용한 입출력 수행
> 사용자 프로그램이 OS에게 일을 대행시킴

* I/O 입출력과 같은 것은 **사용자모드** 에서 사용**불가능**
* `System call`을 이용하여 `trap`을 발생시키고 CPU에 대한 제어권을 **OS로 이양**
    * OS가 일을 **대행함**

---
## Reference
* [2년전 네이버 블로그에 내가 작성한글](https://blog.naver.com/ybook2006/221224620482)
* [운영체제와 정보기술의 원리](http://www.yes24.com/Product/Goods/2824944)
* [Gyoogle님 블로그](https://gyoogle.dev/blog/)
* [한재엽님 레포](https://github.com/JaeYeopHan/Interview_Question_for_Beginner)
* [WeareSoft](https://github.com/WeareSoft/tech-interview)
* [qkraudghgh님 레포](https://github.com/qkraudghgh/coding-interview)
* [박성범님 블로그](https://parksb.github.io/article/5.html)